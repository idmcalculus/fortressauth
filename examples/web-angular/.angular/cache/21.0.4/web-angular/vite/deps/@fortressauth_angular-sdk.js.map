{
  "version": 3,
  "sources": ["../../../../../../../../packages/angular-sdk/src/auth.service.ts"],
  "sourcesContent": ["import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport type { ApiResponse, AuthConfig, AuthState, User } from './types.js';\n\nexport const AUTH_CONFIG = new InjectionToken<AuthConfig>('AUTH_CONFIG');\n\nconst CSRF_COOKIE_NAME = 'fortress_csrf';\nconst CSRF_HEADER_NAME = 'x-csrf-token';\nconst csrfTokenCache = new Map<string, string>();\nconst csrfPromiseCache = new Map<string, Promise<string>>();\n\ndeclare global {\n  interface Window {\n    __FORTRESS_API_URL__?: string;\n  }\n}\n\nfunction resolveBaseUrl(explicit?: string): string {\n  // Check for environment variable in browser context\n  if (typeof window !== 'undefined') {\n    const envUrl = window.__FORTRESS_API_URL__;\n    if (envUrl) return envUrl;\n  }\n  return explicit ?? 'http://localhost:3000';\n}\n\nfunction getCookieValue(name: string): string | null {\n  const doc = (globalThis as { document?: { cookie?: string } }).document;\n  const cookie = doc?.cookie;\n  if (!cookie) return null;\n  const entry = cookie\n    .split(';')\n    .map((part) => part.trim())\n    .find((part) => part.startsWith(`${name}=`));\n  return entry ? decodeURIComponent(entry.slice(name.length + 1)) : null;\n}\n\nasync function fetchCsrfToken(baseUrl: string): Promise<string> {\n  const res = await fetch(`${baseUrl}/auth/csrf`, { credentials: 'include' });\n  const contentType = res.headers.get('content-type');\n  if (contentType?.includes('application/json')) {\n    const data = (await res.json()) as ApiResponse<{ csrfToken: string }>;\n    if (data.success && data.data?.csrfToken) {\n      return data.data.csrfToken;\n    }\n  }\n  throw new Error('CSRF_TOKEN_UNAVAILABLE');\n}\n\nasync function getCsrfToken(baseUrl: string): Promise<string> {\n  const cookieToken = getCookieValue(CSRF_COOKIE_NAME);\n  if (cookieToken) {\n    csrfTokenCache.set(baseUrl, cookieToken);\n    return cookieToken;\n  }\n\n  const cached = csrfTokenCache.get(baseUrl);\n  if (cached) return cached;\n\n  const inflight = csrfPromiseCache.get(baseUrl);\n  if (inflight) return inflight;\n\n  const promise = fetchCsrfToken(baseUrl)\n    .then((token) => {\n      csrfTokenCache.set(baseUrl, token);\n      return token;\n    })\n    .finally(() => {\n      csrfPromiseCache.delete(baseUrl);\n    });\n  csrfPromiseCache.set(baseUrl, promise);\n  return promise;\n}\n\nfunction clearCsrfToken(baseUrl: string): void {\n  csrfTokenCache.delete(baseUrl);\n}\n\nasync function apiRequest<T>(\n  baseUrl: string,\n  path: string,\n  init?: RequestInit,\n  retry = false,\n): Promise<ApiResponse<T>> {\n  try {\n    const method = init?.method?.toUpperCase() ?? 'GET';\n    const requiresCsrf = ['POST', 'PUT', 'PATCH', 'DELETE'].includes(method);\n    let csrfToken: string | undefined;\n    if (requiresCsrf) {\n      try {\n        csrfToken = await getCsrfToken(baseUrl);\n      } catch {\n        csrfToken = undefined;\n      }\n    }\n\n    const res = await fetch(`${baseUrl}${path}`, {\n      ...init,\n      credentials: 'include',\n      headers: {\n        'Content-Type': 'application/json',\n        ...(csrfToken ? { [CSRF_HEADER_NAME]: csrfToken } : {}),\n        ...(init?.headers ?? {}),\n      },\n    });\n    const data = (await res.json()) as ApiResponse<T>;\n    if (!retry && requiresCsrf && !data.success && data.error === 'CSRF_TOKEN_INVALID') {\n      clearCsrfToken(baseUrl);\n      return apiRequest(baseUrl, path, init, true);\n    }\n    return data;\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Network error',\n    };\n  }\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthService {\n  private readonly baseUrl: string;\n  private readonly stateSubject = new BehaviorSubject<AuthState>({\n    user: null,\n    loading: true,\n    error: null,\n  });\n\n  readonly state$: Observable<AuthState> = this.stateSubject.asObservable();\n\n  get user$(): Observable<User | null> {\n    return new Observable((subscriber) => {\n      this.stateSubject.subscribe((state) => subscriber.next(state.user));\n    });\n  }\n\n  get loading$(): Observable<boolean> {\n    return new Observable((subscriber) => {\n      this.stateSubject.subscribe((state) => subscriber.next(state.loading));\n    });\n  }\n\n  get error$(): Observable<string | null> {\n    return new Observable((subscriber) => {\n      this.stateSubject.subscribe((state) => subscriber.next(state.error));\n    });\n  }\n\n  get currentUser(): User | null {\n    return this.stateSubject.getValue().user;\n  }\n\n  get isLoading(): boolean {\n    return this.stateSubject.getValue().loading;\n  }\n\n  get currentError(): string | null {\n    return this.stateSubject.getValue().error;\n  }\n\n  constructor(@Optional() @Inject(AUTH_CONFIG) config?: AuthConfig) {\n    this.baseUrl = resolveBaseUrl(config?.baseUrl);\n    this.refreshUser();\n  }\n\n  private updateState(partial: Partial<AuthState>): void {\n    this.stateSubject.next({\n      ...this.stateSubject.getValue(),\n      ...partial,\n    });\n  }\n\n  async refreshUser(): Promise<void> {\n    this.updateState({ loading: true });\n    const response = await apiRequest<{ user: User }>(this.baseUrl, '/auth/me');\n    if (response.success && response.data) {\n      this.updateState({\n        user: response.data.user,\n        error: null,\n        loading: false,\n      });\n    } else {\n      this.updateState({\n        user: null,\n        error: response.error ?? null,\n        loading: false,\n      });\n    }\n  }\n\n  async signUp(email: string, password: string): Promise<ApiResponse<{ user: User }>> {\n    const response = await apiRequest<{ user: User }>(this.baseUrl, '/auth/signup', {\n      method: 'POST',\n      body: JSON.stringify({ email, password }),\n    });\n    if (response.success && response.data) {\n      this.updateState({ user: response.data.user, error: null });\n    } else {\n      this.updateState({ error: response.error ?? 'UNKNOWN_ERROR' });\n    }\n    return response;\n  }\n\n  async signIn(email: string, password: string): Promise<ApiResponse<{ user: User }>> {\n    const response = await apiRequest<{ user: User }>(this.baseUrl, '/auth/login', {\n      method: 'POST',\n      body: JSON.stringify({ email, password }),\n    });\n    if (response.success && response.data) {\n      this.updateState({ user: response.data.user, error: null });\n    } else {\n      this.updateState({ error: response.error ?? 'UNKNOWN_ERROR' });\n    }\n    return response;\n  }\n\n  async signOut(): Promise<ApiResponse<unknown>> {\n    const response = await apiRequest(this.baseUrl, '/auth/logout', {\n      method: 'POST',\n    });\n    if (response.success) {\n      this.updateState({ user: null });\n    }\n    return response;\n  }\n\n  async verifyEmail(token: string): Promise<ApiResponse<{ verified: boolean }>> {\n    return apiRequest<{ verified: boolean }>(this.baseUrl, '/auth/verify-email', {\n      method: 'POST',\n      body: JSON.stringify({ token }),\n    });\n  }\n\n  async requestPasswordReset(email: string): Promise<ApiResponse<{ requested: boolean }>> {\n    return apiRequest<{ requested: boolean }>(this.baseUrl, '/auth/request-password-reset', {\n      method: 'POST',\n      body: JSON.stringify({ email }),\n    });\n  }\n\n  async resetPassword(\n    token: string,\n    newPassword: string,\n  ): Promise<ApiResponse<{ reset: boolean }>> {\n    return apiRequest<{ reset: boolean }>(this.baseUrl, '/auth/reset-password', {\n      method: 'POST',\n      body: JSON.stringify({ token, newPassword }),\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["AuthService"]
}
