{
  "version": 3,
  "sources": ["../../../../../../../../packages/angular-sdk/src/auth.service.ts"],
  "sourcesContent": ["import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport type { ApiResponse, AuthConfig, AuthState, User } from './types.js';\n\nexport const AUTH_CONFIG = new InjectionToken<AuthConfig>('AUTH_CONFIG');\n\ndeclare global {\n  interface Window {\n    __FORTRESS_API_URL__?: string;\n  }\n}\n\nfunction resolveBaseUrl(explicit?: string): string {\n  // Check for environment variable in browser context\n  if (typeof window !== 'undefined') {\n    const envUrl = window.__FORTRESS_API_URL__;\n    if (envUrl) return envUrl;\n  }\n  return explicit ?? 'http://localhost:3000';\n}\n\nasync function apiRequest<T>(\n  baseUrl: string,\n  path: string,\n  init?: RequestInit,\n): Promise<ApiResponse<T>> {\n  try {\n    const res = await fetch(`${baseUrl}${path}`, {\n      ...init,\n      credentials: 'include',\n      headers: {\n        'Content-Type': 'application/json',\n        ...(init?.headers ?? {}),\n      },\n    });\n    const data = (await res.json()) as ApiResponse<T>;\n    return data;\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Network error',\n    };\n  }\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthService {\n  private readonly baseUrl: string;\n  private readonly stateSubject = new BehaviorSubject<AuthState>({\n    user: null,\n    loading: true,\n    error: null,\n  });\n\n  readonly state$: Observable<AuthState> = this.stateSubject.asObservable();\n\n  get user$(): Observable<User | null> {\n    return new Observable((subscriber) => {\n      this.stateSubject.subscribe((state) => subscriber.next(state.user));\n    });\n  }\n\n  get loading$(): Observable<boolean> {\n    return new Observable((subscriber) => {\n      this.stateSubject.subscribe((state) => subscriber.next(state.loading));\n    });\n  }\n\n  get error$(): Observable<string | null> {\n    return new Observable((subscriber) => {\n      this.stateSubject.subscribe((state) => subscriber.next(state.error));\n    });\n  }\n\n  get currentUser(): User | null {\n    return this.stateSubject.getValue().user;\n  }\n\n  get isLoading(): boolean {\n    return this.stateSubject.getValue().loading;\n  }\n\n  get currentError(): string | null {\n    return this.stateSubject.getValue().error;\n  }\n\n  constructor(@Optional() @Inject(AUTH_CONFIG) config?: AuthConfig) {\n    this.baseUrl = resolveBaseUrl(config?.baseUrl);\n    this.refreshUser();\n  }\n\n  private updateState(partial: Partial<AuthState>): void {\n    this.stateSubject.next({\n      ...this.stateSubject.getValue(),\n      ...partial,\n    });\n  }\n\n  async refreshUser(): Promise<void> {\n    this.updateState({ loading: true });\n    const response = await apiRequest<{ user: User }>(this.baseUrl, '/auth/me');\n    if (response.success && response.data) {\n      this.updateState({\n        user: response.data.user,\n        error: null,\n        loading: false,\n      });\n    } else {\n      this.updateState({\n        user: null,\n        error: response.error ?? null,\n        loading: false,\n      });\n    }\n  }\n\n  async signUp(email: string, password: string): Promise<ApiResponse<{ user: User }>> {\n    const response = await apiRequest<{ user: User }>(this.baseUrl, '/auth/signup', {\n      method: 'POST',\n      body: JSON.stringify({ email, password }),\n    });\n    if (response.success && response.data) {\n      this.updateState({ user: response.data.user, error: null });\n    } else {\n      this.updateState({ error: response.error ?? 'UNKNOWN_ERROR' });\n    }\n    return response;\n  }\n\n  async signIn(email: string, password: string): Promise<ApiResponse<{ user: User }>> {\n    const response = await apiRequest<{ user: User }>(this.baseUrl, '/auth/login', {\n      method: 'POST',\n      body: JSON.stringify({ email, password }),\n    });\n    if (response.success && response.data) {\n      this.updateState({ user: response.data.user, error: null });\n    } else {\n      this.updateState({ error: response.error ?? 'UNKNOWN_ERROR' });\n    }\n    return response;\n  }\n\n  async signOut(): Promise<ApiResponse<unknown>> {\n    const response = await apiRequest(this.baseUrl, '/auth/logout', {\n      method: 'POST',\n    });\n    if (response.success) {\n      this.updateState({ user: null });\n    }\n    return response;\n  }\n\n  async verifyEmail(token: string): Promise<ApiResponse<{ verified: boolean }>> {\n    return apiRequest<{ verified: boolean }>(this.baseUrl, '/auth/verify-email', {\n      method: 'POST',\n      body: JSON.stringify({ token }),\n    });\n  }\n\n  async requestPasswordReset(email: string): Promise<ApiResponse<{ requested: boolean }>> {\n    return apiRequest<{ requested: boolean }>(this.baseUrl, '/auth/request-password-reset', {\n      method: 'POST',\n      body: JSON.stringify({ email }),\n    });\n  }\n\n  async resetPassword(\n    token: string,\n    newPassword: string,\n  ): Promise<ApiResponse<{ reset: boolean }>> {\n    return apiRequest<{ reset: boolean }>(this.baseUrl, '/auth/reset-password', {\n      method: 'POST',\n      body: JSON.stringify({ token, newPassword }),\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["AuthService"]
}
